package utilis

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"net/http"
	"time"

	"github.com/ratheeshkumar25/opti_cut_chat_service/config"
)

// Define the request structure for OpenAI API
type openAIRequest struct {
	Model       string  `json:"model"`
	Prompt      string  `json:"prompt"`
	MaxTokens   int     `json:"max_tokens"`
	Temperature float64 `json:"temperature"`
	TopP        float64 `json:"top_p"`
	N           int     `json:"n"`
}

// Define the response structure for OpenAI API
type openAIResponse struct {
	Choices []struct {
		Text string `json:"text"`
	} `json:"choices"`
}

// The OpenAI endpoint URL
const openAIEndpoint = "https://api.openai.com/v1/completions"

// CallAIChatbotAPI makes a call to the OpenAI API and returns the generated response
func CallAIChatbotAPI(userMessage, model string) (string, error) {
	// Load the OpenAI API key from the configuration
	apiKey := config.LoadConfig().OpenApiKey
	if apiKey == "" {
		log.Println("Error: API key is missing")
		return "", errors.New("API key is missing")
	}

	// If no model is provided, use the default
	if model == "" {
		model = "text-davinci-003"
	}

	// Prepare the request body
	reqBody := openAIRequest{
		Model:       model,
		Prompt:      userMessage,
		MaxTokens:   150, // Maximum tokens in the response
		Temperature: 0.7, // Controls randomness in the response
		TopP:        1.0, // Controls diversity
		N:           1,   // Number of responses to generate
	}

	// Marshal the request body to JSON
	jsonData, err := json.Marshal(reqBody)
	if err != nil {
		log.Printf("Error marshalling request body: %v", err)
		return "", err
	}

	// Create an HTTP client with a timeout
	client := &http.Client{
		Timeout: 10 * time.Second,
	}

	// Create the POST request
	req, err := http.NewRequest("POST", openAIEndpoint, bytes.NewBuffer(jsonData))
	if err != nil {
		log.Printf("Error creating request: %v", err)
		return "", err
	}

	// Set the necessary headers
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+apiKey)

	// Retry logic for network issues or timeouts
	var resp *http.Response
	for retries := 0; retries < 3; retries++ {
		resp, err = client.Do(req)
		if err == nil && resp.StatusCode == http.StatusOK {
			break
		}
		if retries < 2 {
			log.Printf("Retrying... attempt %d", retries+1)
			time.Sleep(2 * time.Second) // backoff time before retry
		}
	}

	// If all retries fail, return the error
	if err != nil {
		log.Printf("Error making request to OpenAI API: %v", err)
		return "", fmt.Errorf("failed after retries: %v", err)
	}
	defer resp.Body.Close()

	// Check for successful response
	if resp.StatusCode != http.StatusOK {
		log.Printf("API call failed with status code: %d", resp.StatusCode)
		return "", fmt.Errorf("failed to get a response from the AI service, status code: %d", resp.StatusCode)
	}

	// Parse the JSON response from the AI service
	var aiResp openAIResponse
	err = json.NewDecoder(resp.Body).Decode(&aiResp)
	if err != nil {
		log.Printf("Error decoding response: %v", err)
		return "", err
	}

	// If no response text is available, return an error
	if len(aiResp.Choices) == 0 {
		log.Println("Error: No choices returned from AI service")
		return "", errors.New("no choices returned from AI service")
	}

	// Return the text response generated by the AI
	return aiResp.Choices[0].Text, nil
}
